diff --git a/include/longestPalindromicSubstring.h b/include/longestPalindromicSubstring.h
new file mode 100644
index 0000000..b2bd0cb
--- /dev/null
+++ b/include/longestPalindromicSubstring.h
@@ -0,0 +1,113 @@
+#if defined(INCLUDED_SOLUTION_HEADER)
+static_assert(false, "Won't include multiple solution headers together!")
+#else
+#define INCLUDED_SOLUTION_HEADER "005"
+
+/*!
+ *  \brief Given a string, return the longest substring of
+ *         that string that is also a palindrome.
+ *
+ *
+ * This question is identical to finding the longest
+ * common substring between a string and its reverse.
+ *
+ * The solution naive solution's recursion tree (O(2^n) RIP)
+ * reveals an important fact:
+ * If s[n,k] is a solution and so is s[m,h] (n < m and k < h),
+ * s[n,h] is also a solution as long as both the ranges overlap.
+ *
+ * So we can build up bottom-up solution, we'd need to record
+ * the index of each of the matches in a matrix, and seach along
+ * diagnol routes like (i,j) -> (i+1,j+1) searching for the longest
+ * sequence. At any time, we are interested in *ONLY* one diagnol, so
+ * that could be a potential memory optimization. There are two levels
+ * of optimality here, both have T in O(n^2), one of them with O(n^2)
+ * memory. The other one generates diagnal rows on the fly.
+ *
+ * Note that the matches will *ALWAYS* occur on a diagnol path, and will
+ * have a linearly increasing sequence of indices. The diagnol can occur
+ * either be a Right upper triangle or left bottom triangle. Main diagnol
+ * matches mean
+ */
+
+#include <iostream>
+#include <queue>
+#include <string>
+#include <vector>
+
+#include "Common.h"
+
+namespace p005 {
+class Solution {
+private:
+  using position_t = std::pair<int, int>;
+
+  bool isPalindrome(std::string &s) {
+    bool palindromic = true;
+    auto cit = s.cbegin();
+    auto crit = s.crbegin();
+    for (; cit != s.cend() && crit != s.crend(); ++cit, ++crit) {
+      palindromic &= ((*cit) == (*crit));
+    }
+    return palindromic;
+  }
+
+  inline size_t mdist(position_t start, position_t end) {
+    return abs(start.first - end.first) + abs(start.second - end.second);
+  }
+
+public:
+  std::string longestPalindrome(std::string s) {
+    size_t length = s.size();
+    if (length < 2 || isPalindrome(s)) {
+      return s;
+    }
+
+    std::vector<std::vector<short>> in_palindrome{
+        length, std::vector<short>(length, 0)};
+
+    for (size_t i = 0, len = length; i < length; ++i) {
+      for (size_t j = 0; j < length; ++j) {
+        if (s[len - 1 - i] == s[j]) {
+          in_palindrome[i][j] = 1;
+        }
+        std::cout << in_palindrome[i][j] << " ";
+      }
+      std::cout << std::endl;
+    }
+
+    std::pair<size_t, size_t> best_start{0, 0};
+    std::pair<size_t, size_t> best_end{0, 0};
+
+    // Only look for length 2 and above since we find length 1 by default
+    for (size_t i = 0; i < length - 1; ++i) {
+      for (size_t j = 0; j < length - 1; ++j) {
+        // Start counting down right
+        if (in_palindrome[i][j]) {
+          std::pair<size_t, size_t> end{i, j};
+          while (end.first < length - 1 && end.second < length - 1 &&
+                 in_palindrome[end.first + 1][end.second + 1]) {
+            ++end.first;
+            ++end.second;
+            // Never visit this chain again
+            in_palindrome[end.first][end.second] = 0;
+          }
+          if (mdist(best_start, best_end) < mdist({i, j}, end)) {
+            best_start = {i, j};
+            best_end = end;
+          }
+        }
+      }
+    }
+
+    // Match occurred in lower triangular part
+    if (best_start.second < best_end.second) {
+      return s.substr(best_start.second,
+                      best_end.second - best_start.second + 1);
+    }
+    return s.substr(best_start.first, best_end.first - best_start.first + 1);
+  }
+};
+} // namespace p005
+
+#endif // INCLUDED_SOLUTION_HEADER
diff --git a/src/005-Longest-Palindromic-Substring.cpp b/src/005-Longest-Palindromic-Substring.cpp
new file mode 100644
index 0000000..6c01a6d
--- /dev/null
+++ b/src/005-Longest-Palindromic-Substring.cpp
@@ -0,0 +1 @@
+#include "longestPalindromicSubstring.h"
diff --git a/test/005-Longest-Palindromic-Substring.t.cpp b/test/005-Longest-Palindromic-Substring.t.cpp
new file mode 100644
index 0000000..1504f06
--- /dev/null
+++ b/test/005-Longest-Palindromic-Substring.t.cpp
@@ -0,0 +1,65 @@
+#include <gtest/gtest.h>
+
+#include "Common.h"
+#include "longestPalindromicSubstring.h"
+
+class P005_LongestPalindromicSubstring : public ::testing::Test {
+protected:
+  p005::Solution sol;
+};
+
+TEST_F(P005_LongestPalindromicSubstring, EmptyStr) {
+
+  EXPECT_EQ(sol.longestPalindrome(""), "");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, TrivialPalindrome) {
+
+  EXPECT_EQ(sol.longestPalindrome("the quick brown fox"), "t");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, FullMatch1) {
+
+  EXPECT_EQ(sol.longestPalindrome("a"), "a");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, FullMatch2) {
+
+  EXPECT_EQ(sol.longestPalindrome("bb"), "bb");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, FullMatch3) {
+
+  EXPECT_EQ(sol.longestPalindrome("ccc"), "ccc");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, FullMatch4) {
+
+  EXPECT_EQ(sol.longestPalindrome("racecar"), "racecar");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, LatterHalf0) {
+
+  std::string lp(sol.longestPalindrome("xc"));
+  EXPECT_TRUE(lp == "x" || lp == "c");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, LatterHalf1) {
+
+  EXPECT_EQ(sol.longestPalindrome("xxyx"), "xyx");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, LatterHalf2) {
+
+  EXPECT_EQ(sol.longestPalindrome("some_prefixxyx"), "xyx");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, LatterHalf3) {
+
+  EXPECT_EQ(sol.longestPalindrome("ilikeracecars"), "racecar");
+}
+
+TEST_F(P005_LongestPalindromicSubstring, FormerHalf1) {
+
+  EXPECT_EQ(sol.longestPalindrome("racecarsilike"), "racecar");
+}
